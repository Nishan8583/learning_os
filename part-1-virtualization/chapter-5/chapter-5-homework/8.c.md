Write a program that creates two children, and connects the standard output of one to the standard input of the other, using the pipe() system call.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
//https://www.geeksforgeeks.org/c/c-program-demonstrate-fork-and-pipe/
int main() {
    // 2 piples
    // first pipes used by parent to send data to child
    // second piples where child sends data to parent

    int parent_fd[2];
    int child_fd[2];

    // pipe syscall takes the array and create a pipe, an object that allows for bidirectional communication. first descripted (index) is read end, and second is the write end
    if (pipe(parent_fd) == -1) {
        perror("parent_fd failed");
        exit(1);
    }

    if (pipe(child_fd) == -1) {
        perror("child_fd failed");
        exit(1);
    }

    printf("Please enter something: ");
    // get input from the user
    char input_str[100] = {0};
    scanf("%s",input_str);

    int rc = fork();

    if (rc < 0) {
        perror("fork failed ");
        exit(1);
    } else if (rc > 0) {
        //parent process;
        close(parent_fd[0]); // close the read end of parent_fd

        write(parent_fd[1],input_str,strlen(input_str)+1); // write to the write end of parent_fd
        close(parent_fd[1]); // close the write end of parent_fd after writing

        wait(NULL); // wait for child to finish writing back

        close(child_fd[1]);// close the write end of child_fd because we won't write to it

        char end_result[100] = {0};
        read(child_fd[0],end_result,100); // read from the read end of child_fd
        printf("Parent received: %s\n",end_result);
        close(child_fd[0]); // close the read end of child_fd

    } else if (rc == 0){
        // child process
        close(parent_fd[1]);// close the write end of child_fd

        char str_1[100] = {0};
        read(parent_fd[0],str_1,100); // read from the read end of parent_fd

        write(child_fd[1],str_1,strlen(str_1)+1); // write to the write end of child_fd
        close(child_fd[1]); // close the write end of child_fd after writing
        //close(parent_fd[0]); // close the read end of parent_fd
    }
    exit(0);
}
```

## Why so many close in the code ?
`TLDR: Closing Sends EOF, without EOF read will be in deadlock, also to prevent resource exhaustion`

The reason there are so many `close()` calls for file descriptors in your code is because of how **pipes** work in Unix-like systems and the need to properly manage resources. Pipes are unidirectional communication channels, and each pipe has two ends: a **read end** and a **write end**. When using pipes in a program with multiple processes (like parent and child), it is crucial to close the ends of the pipe that are not being used in each process. This ensures proper communication, avoids resource leaks, and prevents deadlocks.

Let’s break it down step by step:

---

### **1. Why do we need to close file descriptors?**

- **Resource Management**: File descriptors are limited system resources. If you don’t close unused file descriptors, you may run out of them, causing your program or other programs to fail.
- **Proper Behavior of Pipes**: Pipes rely on the concept of EOF (End of File). If a process doesn’t close the write end of a pipe, the reader will never see an EOF, and `read()` will block indefinitely, waiting for more data.
- **Avoid Deadlocks**: If both processes are waiting on each other to send or receive data but haven’t closed the appropriate ends of the pipe, a deadlock can occur.

---

### **2. Why do we close specific ends of the pipe?**

Each process (parent and child) uses the pipe in a specific way:

- **Parent Process**:
    - Writes data to the child via the **write end** of `parent_fd`.
    - Reads data from the child via the **read end** of `child_fd`.
- **Child Process**:
    - Reads data from the parent via the **read end** of `parent_fd`.
    - Writes data back to the parent via the **write end** of `child_fd`.

To avoid interference and ensure proper communication:

- Each process **closes the ends of the pipe it does not use**. For example:
    - The parent doesn’t need to read from `parent_fd` (it only writes to it), so it closes the **read end** of `parent_fd`.
    - The child doesn’t need to write to `parent_fd` (it only reads from it), so it closes the **write end** of `parent_fd`.

---

### **3. Detailed Explanation of `close()` Calls in Your Code**

#### **Parent Process**

1. **`close(parent_fd[0]);`**
    
    - The parent closes the **read end** of `parent_fd` because it only writes to this pipe. Keeping it open is unnecessary and could cause issues (e.g., deadlocks).
2. **`close(parent_fd[1]);`**
    
    - After writing data to the child, the parent closes the **write end** of `parent_fd`. This is important because it signals EOF to the child, letting the child know that no more data will be sent.
3. **`close(child_fd[1]);`**
    
    - The parent closes the **write end** of `child_fd` because it only reads from this pipe. Keeping it open is unnecessary.
4. **`close(child_fd[0]);`**
    
    - After reading the data sent back by the child, the parent closes the **read end** of `child_fd` to clean up resources.

---

#### **Child Process**

1. **`close(parent_fd[1]);`**
    
    - The child closes the **write end** of `parent_fd` because it only reads from this pipe. Keeping it open is unnecessary.
2. **`close(child_fd[0]);`**
    
    - The child closes the **read end** of `child_fd` because it only writes to this pipe. Keeping it open is unnecessary.
3. **`close(child_fd[1]);`**
    
    - After writing data back to the parent, the child closes the **write end** of `child_fd` to signal EOF to the parent.

---

### **4. What Happens If You Don’t Close File Descriptors?**

- **Resource Leaks**: The operating system keeps track of open file descriptors. If you don’t close them, they remain open until the process terminates, wasting resources.
- **Deadlocks**: If a process is waiting for data on a pipe but the other process hasn’t closed the corresponding end, the waiting process may block indefinitely.
- **Unexpected Behavior**: For example, if both the parent and child keep the write end of a pipe open, the reader will never see EOF, causing `read()` to block forever.

---

### **5. Summary of Logic**

- **Close unused ends**: Each process closes the ends of the pipe it doesn’t need to use.
- **Signal EOF**: Closing the write end of a pipe signals EOF to the reader.
- **Clean up resources**: Closing file descriptors ensures that system resources are freed.

Here’s a table summarizing which ends are closed by each process:

|**Pipe**|**Parent Closes**|**Child Closes**|
|---|---|---|
|`parent_fd[0]`|**Yes** (not used)|**No** (used for reading)|
|`parent_fd[1]`|**Yes** (after writing)|**Yes** (not used)|
|`child_fd[0]`|**Yes** (not used)|**Yes** (not used)|
|`child_fd[1]`|**Yes** (after reading)|**Yes** (after writing)|

By following this logic, you ensure proper communication and avoid resource leaks or deadlocks.

## File descriptor tables are shared between parent and child after fork

When you call `fork()`, the child process **inherits** the file descriptors from the parent process. This means that the child process gets **copies** of the parent's file descriptors, and these copies refer to the **same underlying pipe objects** in the kernel. As a result, the parent and child processes can communicate with each other through the same pipes.

Let me explain this in detail:

---

### **1. What Happens to File Descriptors After `fork()`?**

When a process calls `fork()`, the child process is created as a copy of the parent process. This includes:

- The **file descriptor table**: The child inherits all open file descriptors from the parent. These file descriptors in the child point to the same underlying kernel objects (e.g., pipes, files, sockets) as the parent's file descriptors.
- The **reference counts** for the file descriptors are incremented, meaning both the parent and child now share access to the same resources.

So, if the parent process creates a pipe using `pipe()`, the child process will inherit the file descriptors for that pipe. Both processes can then use the pipe for communication.

---

### **2. Why Can the Parent and Child Communicate Through the Same Pipe?**

Pipes are kernel-level objects that allow unidirectional communication between processes. When you call `pipe(parent_fd)`:

- The kernel creates a pipe object with two ends: a **read end** (`parent_fd[0]`) and a **write end** (`parent_fd[1]`).
- The parent process gets access to both ends of the pipe.
- After `fork()`, the child process also gets access to the same pipe object through its inherited file descriptors.

This shared access allows the parent and child to communicate:

- The parent can write data to the pipe's **write end** (`parent_fd[1]`), and the child can read that data from the pipe's **read end** (`parent_fd[0]`).
- Similarly, if you create another pipe (`child_fd`), the child can write to it, and the parent can read from it.

---

### **3. Why Do We Need to Close File Descriptors in Both Processes?**

Even though the parent and child share the same underlying pipe object, they each have their own **copies** of the file descriptors. If you don’t close the unused ends of the pipe in each process, the following issues can occur:

#### **a. Deadlocks**

- If the parent writes to the pipe but doesn’t close the **read end** in its own process, the child might block indefinitely when trying to read, because the pipe will never signal EOF (End of File).
- Similarly, if the child writes to the pipe but doesn’t close the **read end**, the parent might block indefinitely when trying to read.

#### **b. Resource Leaks**

- Each open file descriptor consumes system resources. If you don’t close unused file descriptors, you may run out of file descriptors, especially in programs that create many pipes or processes.

#### **c. Proper Communication**

- Closing unused ends ensures that data flows correctly between the parent and child. For example:
    - When the parent closes the **write end** of a pipe after writing, it signals EOF to the child, letting the child know that no more data will be sent.
    - When the child closes the **read end** of a pipe after reading, it ensures that the parent doesn’t block indefinitely waiting for the child to read.

---

### **4. Why Doesn’t Each Process Have Its Own Separate Pipe?**

The `pipe()` system call creates a single pipe object in the kernel. This pipe is shared between the parent and child processes after `fork()`. If you want completely separate pipes for the parent and child, you would need to call `pipe()` **after** `fork()` in both the parent and child processes. However, this would defeat the purpose of using pipes for communication between the two processes.

In your code, you create two pipes (`parent_fd` and `child_fd`) **before** calling `fork()`. This ensures that both the parent and child can use these pipes to communicate with each other:

- `parent_fd`: Used for the parent to send data to the child.
- `child_fd`: Used for the child to send data back to the parent.

---

### **5. Summary of How Communication Works in Your Code**

1. **Before `fork()`**:
    
    - Two pipes (`parent_fd` and `child_fd`) are created. Each pipe has a read end and a write end.
    - The parent process has access to both ends of both pipes.
2. **After `fork()`**:
    
    - The child process inherits the file descriptors for both pipes.
    - Both processes now share access to the same pipe objects in the kernel.
3. **Communication**:
    
    - The parent writes data to the **write end** of `parent_fd`. The child reads this data from the **read end** of `parent_fd`.
    - The child writes data to the **write end** of `child_fd`. The parent reads this data from the **read end** of `child_fd`.
4. **Closing File Descriptors**:
    
    - Each process closes the ends of the pipes it doesn’t use. This ensures proper communication, avoids deadlocks, and frees up system resources.

---

### **6. Visualization of the Pipe Communication**

|**Pipe**|**Parent Uses**|**Child Uses**|
|---|---|---|
|`parent_fd[0]`|Not used (closed)|Used for reading|
|`parent_fd[1]`|Used for writing|Not used (closed)|
|`child_fd[0]`|Used for reading|Not used (closed)|
|`child_fd[1]`|Not used (closed)|Used for writing|

---

### **7. What If You Want Separate Pipes for Parent and Child?**

If you want completely separate pipes for the parent and child (i.e., no shared communication), you would need to:

1. Call `pipe()` in the parent process.
2. Call `fork()`.
3. Call `pipe()` again in the child process.

However, this is not the typical use case for pipes. Pipes are usually used for communication between parent and child processes, which is why the file descriptors are shared after `fork()`.

---

**local variables are not shared** between the parent and child processes after a `fork()`. Each process gets its own copy of the parent's memory space, including the stack, heap, and data segments. Changes made to local variables in one process do not affect the other process because they operate on separate memory spaces.

---
